plugins {
    id 'application'
    id 'io.freefair.lombok' version '8.6'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'maven-publish'

}

def isCI = System.getenv("CI")?.toBoolean() ?: false

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import groovy.json.JsonSlurper

apply from: 'generate-plugins.gradle'

tasks.named('shadowJar') {
    enabled = false
}

// Create a resolvable configuration just for running microbot
configurations {
    microbotRuntime {
        canBeConsumed = false
        canBeResolved = true
    }

    pluginShadowClasspath {
        extendsFrom runtimeClasspath
        exclude group: 'net.runelite', module: 'microbot'
    }
}

repositories {
    maven {
        url = 'https://nexus.microbot.cloud/repository/microbot-nightly/'
    }
    mavenCentral()
}

dependencies {
    compileOnly 'com.microbot:client:1.9.6.1'
    microbotRuntime 'com.microbot:client:1.9.6.1'
}

application {
    // Replace this with the actual main class inside your shaded jar
    mainClass = 'net.runelite.client.RuneLite'
}

def static pluginVersionFromPluginJson(File pluginDir) {
    def pluginJson = new File(pluginDir, "plugin.json")
    if (!pluginJson.exists()) return "0.0.1"
    def json = new JsonSlurper().parseText(pluginJson.text)
    return json.version ?: "0.0.1"
}


// Plugin Logic

def pluginsDir = file('src/main/java/com/microbot/plugins')
def pluginDirs = pluginsDir.listFiles()?.findAll { it.isDirectory() } ?: []

println "Detected plugins: " + pluginDirs*.name

def pluginsProperty = project.findProperty("pluginList")
def selectedPlugins = pluginsProperty ? pluginsProperty.split(',' as Closure).collect { it.trim() } : []

// Create a sourceSet + ShadowJar per plugin
pluginDirs.each { pluginDir ->
    def pluginName = ""

    def pluginJavaFile = pluginDir.listFiles()?.find { file ->
        file.name.endsWith("Plugin.java")
    }

    if (pluginJavaFile) {
        pluginName = pluginJavaFile.name[0..-6] // removes '.java'
        println "Found plugin class: ${pluginJavaFile.name}"
    } else {
        println "⚠️ No Plugin.java file found in $pluginName"
    }

    if (selectedPlugins && !selectedPlugins.contains(pluginName)) {
        println "Skipping plugin: $pluginName"
        return
    }

    // Create a dependencySet for each plugin
    def pluginConfigName = "${pluginName}ShadowDeps"
    configurations.create(pluginConfigName) {
        extendsFrom configurations.pluginShadowClasspath
    }

    def depsFile = new File(pluginDir as File, "dependencies.txt")
    if (depsFile.exists()) {
        depsFile.readLines().each { dep ->
            println("dep " + dep.trim())
            dependencies.add(pluginConfigName, dep.trim())
        }
    }

    // Create a sourceset for each plugin
    def ss = sourceSets.create(pluginName) {
        java.srcDir pluginDir
        compileClasspath += sourceSets.main.compileClasspath
        runtimeClasspath += sourceSets.main.runtimeClasspath
    }

    // Create a ShadowJar task for each plugin
    def jarTask = tasks.register("${pluginName}Jar", ShadowJar) {
        archiveBaseName.set(pluginName)
        archiveVersion.set(pluginVersionFromPluginJson(pluginDir as File))          // => pluginName.jar
        archiveClassifier.set('')       // no -all
        from ss.output
        // configurations = [project.configurations.pluginShadowClasspath]
        //noinspection ConfigurationAvoidance
        configurations = [project.configurations.getByName(pluginConfigName)]
        destinationDirectory.set(layout.buildDirectory.dir("libs"))

        duplicatesStrategy = DuplicatesStrategy.EXCLUDE
        // Exclude module-info.class entirely (you don't need modules for plugins)
        exclude 'module-info.class'
        exclude 'META-INF/versions/**'
        exclude '**/plugin.json'
        exclude '**/plugins.json'
        outputs.upToDateWhen { isCI }
    }

    def copyTask = tasks.register("copy${pluginName}ToMicrobot", Copy) {
        dependsOn(jarTask)
        from(jarTask.flatMap { it.archiveFile })   // never hardcode build/libs/...
        into("${System.properties['user.home']}/.runelite/microbot-plugins")
        outputs.upToDateWhen { isCI } // Always run
    }

    jarTask.configure {
        dependsOn("generatePluginsJson")
        from("$buildDir/generated/resources/plugins.json") {
            into("/")
            rename { "plugins.json" }
        }
    }

    afterEvaluate {
        publishing {
            publications {
                create("${pluginName}Publication", MavenPublication) {
                    groupId = "com.microbot.plugins"
                    artifactId = pluginName.toLowerCase()
                    version = pluginVersionFromPluginJson(pluginDir as File)

                    artifact(tasks.named("${pluginName}Jar").get().archiveFile) {
                        extension "jar"
                    }
                }
            }

            repositories {
                maven {
                    name = "microbot-plugins"
                    url = uri("https://nexus.microbot.cloud/repository/microbot-plugins/")
                    credentials {
                        username = project.findProperty("nexusUsername") ?: ""
                        password = project.findProperty("nexusPassword") ?: ""
                    }
                }
            }
        }
    }

    // Only make build depend on it if you want it to always run
    tasks.named("build") {
        dependsOn(jarTask)
        if (!isCI) {
            dependsOn(copyTask)
            dependsOn("runMicrobot")
        }
    }
}

tasks.withType(Jar).configureEach {
    preserveFileTimestamps = false
    reproducibleFileOrder = true

    // Set Unix permissions consistently
    eachFile { fileCopyDetails ->
        fileCopyDetails.mode = 0644 // rw-r--r--
    }
}

tasks.register("runMicrobot", Exec) {
    if (pluginsProperty) {
        commandLine 'java', '-jar', configurations.microbotRuntime.singleFile, "--plugins=${pluginsProperty}"
    } else {
        commandLine 'java', '-jar', configurations.microbotRuntime.singleFile
    }
}

tasks.register("copyPluginDocs") {
    group = "documentation"
    description = "Copies plugin README.md files and images to the public directory for GitHub Pages"

    doLast {
        def publicDir = file("public/docs")
        publicDir.mkdirs()

        pluginDirs.each { pluginDir ->
            def pluginName = pluginDir.name
            def readmeFile = pluginDir.listFiles()?.find { file ->
                file.name.equalsIgnoreCase("readme.md")
            }
            def imagesDir = new File(pluginDir, "images")

            if (readmeFile.exists()) {
                // Create plugin docs directory
                def pluginDocsDir = new File(publicDir, pluginName)
                pluginDocsDir.mkdirs()

                // Copy README.md
                copy {
                    from readmeFile
                    into pluginDocsDir
                }

                println "✅ Copied README.md for plugin: ${pluginName}"

                // Copy images if they exist
                if (imagesDir.exists() && imagesDir.isDirectory()) {
                    copy {
                        from imagesDir
                        into new File(pluginDocsDir, "images")
                    }
                    println "✅ Copied images for plugin: ${pluginName}"
                }
            }
        }
    }
}

// Update your GitHub Pages deployment to include the docs
tasks.named("generatePluginsJson") {
    if (isCI) {
        finalizedBy("copyPluginDocs")
    }
}