plugins {
    id 'application'
    id 'java'
    id 'io.freefair.lombok' version '8.6'
    id 'com.github.johnrengelman.shadow' version '8.1.1'
    id 'maven-publish'
    id 'idea'
}

import com.github.jengelman.gradle.plugins.shadow.tasks.ShadowJar
import groovy.json.JsonOutput

apply from: 'gradle/project-config.gradle'
apply from: 'gradle/plugin-utils.gradle'

// Java toolchain configuration
java {
    toolchain {
        languageVersion = JavaLanguageVersion.of(project.ext.TARGET_JDK_VERSION)
        vendor = JvmVendorSpec."${project.ext.JDK_VENDOR}"
    }
}

idea {
    module {
        downloadSources = false
    }
}

tasks.withType(JavaCompile).configureEach {
    options.encoding = 'UTF-8'
    options.release = project.ext.TARGET_JDK_VERSION
    options.compilerArgs.addAll([
        '-parameters',
        '-Xlint:none',
        '-g:none'
    ])


    options.fork = true
    options.forkOptions.jvmArgs = ['-Dfile.encoding=UTF-8']
}

configurations {
    microbotRuntime {
        canBeConsumed = false
        canBeResolved = true
    }

    pluginShadowClasspath {
        extendsFrom runtimeClasspath
        exclude group: 'net.runelite', module: 'microbot'
    }

    // Disable source downloads for all configurations
    configureEach {
        resolutionStrategy {
            eachDependency { details ->
                if (details.target.group == 'com.microbot' && details.target.name == 'client') {
                    details.artifactSelection {
                        selectArtifact(DependencyArtifact.DEFAULT_TYPE, null, null)
                    }
                }
            }
        }
    }
}

repositories {
    maven {
        url = project.ext.getNexusNightlyUrl()
    }
    mavenCentral()
}

dependencies {
    compileOnly 'com.microbot:client:+'
    microbotRuntime 'com.microbot:client:+'

    testImplementation 'com.microbot:client:+'
}

application {
    // Replace this with the actual main class inside your shaded jar
    mainClass = 'net.runelite.client.RuneLite'
}

sourceSets.main.java.srcDirs = []
sourceSets.main.resources.srcDirs = []

tasks.named('compileJava') {
    enabled = false
}
tasks.named('processResources') {
    enabled = false
}
tasks.named('classes') {
    enabled = false
}
tasks.named('jar') {
    enabled = false
}

tasks.named('shadowJar') {
    enabled = false
}

// Plugin Logic
String pluginVersionFromPluginJson(File pluginDir) {
    def pluginJavaFile = pluginDir.listFiles()?.find { it.name.endsWith("Plugin.java") }
    if (pluginJavaFile == null) {
        throw new GradleException("No *Plugin.java found in: $pluginDir")
    }
    def info = ext.getPluginDescriptorInfo(pluginJavaFile) as Map  // ext == project.ext
    return info.version as String
}

// Discover and filter plugins
afterEvaluate {
    def microbotConfig = configurations.microbotRuntime.resolvedConfiguration
    def microbotDependency = microbotConfig.firstLevelModuleDependencies
            .find { it.moduleGroup == 'com.microbot' && it.moduleName == 'client' }

    if (microbotDependency) {
        logger.lifecycle("ü§ñ Microbot Client Version: ${microbotDependency.moduleVersion}")
    } else {
        logger.warn("‚ö†Ô∏è  Could not determine microbot client version")
    }

    def pluginsDir = file(project.ext.getPluginsSourcePath())
    def allPlugins = project.ext.discoverPlugins(pluginsDir)
    def pluginsProperty = project.findProperty("pluginList")
    def selectedPluginNames = pluginsProperty ? pluginsProperty.split(',').collect { it.trim() } : []

    def validPlugins = allPlugins.findAll { plugin ->
        if (selectedPluginNames && !selectedPluginNames.contains(plugin.name)) {
            logger.info("Skipping plugin: ${plugin.name}")
            return false
        }
        logger.info("Processing plugin: ${plugin.name}")
        return true
    }

    println "Detected plugins: ${allPlugins*.name}"
    println "Processing plugins: ${validPlugins*.name}"

    ext.validPlugins = validPlugins
    ext.allPlugins = allPlugins

    def pluginPublications = []

    validPlugins.each { plugin ->
        // Configure source set
        project.ext.configurePluginSourceSet(plugin)

        // Configure dependencies
        def pluginConfigName = project.ext.configurePluginDependencies(plugin)

        // Create JAR task using the configuration
        def jarTask = tasks.register("${plugin.name}Jar", ShadowJar, project.ext.getPluginJarTaskConfig(plugin, pluginConfigName))

        // Add to build dependencies
        tasks.named("build") {
            dependsOn(jarTask)
        }

        // Collect for publishing
        pluginPublications << [
            name    : plugin.name,
            jarTask : jarTask,
            version : pluginVersionFromPluginJson(plugin.dir)
        ]
    }

    // Configure publishing
    publishing {
        publications {
            pluginPublications.each { pub ->
                create("${pub.name}Publication", MavenPublication) {
                    groupId = project.ext.MAVEN_GROUP_ID
                    artifactId = pub.name.toLowerCase()
                    version = pub.version

                    artifact(pub.jarTask.get().archiveFile) {
                        extension "jar"
                    }
                }
            }
        }
        repositories {
            maven {
                name = "microbot-plugins"
                url = uri(project.ext.getNexusPluginsUrl())
                credentials {
                    username = project.findProperty("nexusUsername") ?: ""
                    password = project.findProperty("nexusPassword") ?: ""
                }
            }
        }
    }

    // Configure test source set to have access to all plugin source sets
    def allPluginCompileTasks = []

    validPlugins.each { plugin ->
        def compileTaskName = "compile${plugin.sourceSetName.capitalize()}Java"

        if (sourceSets.findByName(plugin.sourceSetName)) {
            sourceSets.test.compileClasspath += sourceSets."${plugin.sourceSetName}".output
            sourceSets.test.runtimeClasspath += sourceSets."${plugin.sourceSetName}".output

            allPluginCompileTasks.add(compileTaskName)

            dependencies.add('testRuntimeOnly', sourceSets."${plugin.sourceSetName}".output)
            dependencies.add('testCompileOnly', sourceSets."${plugin.sourceSetName}".output)
        }
    }

    tasks.named('compileTestJava').configure {
        dependsOn allPluginCompileTasks
    }

    tasks.named('test').configure {
        dependsOn allPluginCompileTasks
    }
}

tasks.register("copyPluginDocs") {
    group = "documentation"
    description = "Copies plugin README.md files and resources to the public directory for GitHub Pages"

    doLast {
        def publicDir = file(project.ext.getDocsOutputPath())
        publicDir.mkdirs()

        def pluginsDir = file(project.ext.getPluginsSourcePath())
        def allPlugins = project.ext.discoverPlugins(pluginsDir)
        def pluginsProperty = project.findProperty("pluginList")
        def selectedPluginNames = pluginsProperty ? pluginsProperty.split(',').collect { it.trim() } : []

        def validPlugins = allPlugins.findAll { plugin ->
            if (selectedPluginNames && !selectedPluginNames.contains(plugin.name)) {
                return false
            }
            return true
        }

        validPlugins.each { plugin ->
            project.ext.copyPluginDocumentation(plugin, publicDir)
        }
    }
}

// Validating JDK version when generating plugins.json is important to ensure consistent hashing :(
tasks.register("generatePluginsJson") {
    group = "build"
    description = "Generates plugins.json by scanning plugin folders and hashing JARs"
    dependsOn 'validateJdkVersion'

    doLast {
        def pluginRoot = file(project.ext.getPluginsSourcePath())
        def outputJson = file("${project.ext.getDocsOutputPath()}/plugins.json")
        def jarOutputDir = file("$buildDir/libs")

        def allPlugins = project.ext.discoverPlugins(pluginRoot)
        def plugins = project.ext.generatePluginsJsonData(allPlugins, jarOutputDir)

        outputJson.parentFile.mkdirs()
        outputJson.text = JsonOutput.prettyPrint(JsonOutput.toJson(plugins))
        logger.info("‚úÖ Generated plugins.json with ${plugins.size()} plugins")
    }
}

tasks.register('validateJdkVersion') {
    group = 'verification'
    description = 'Validates that the correct JDK version is being used'

    doLast {
        def currentJdkVersion = System.getProperty('java.version')
        def expectedVersion = project.ext.TARGET_JDK_VERSION

        // Extract major version from full version string (e.g., "11.0.28" -> 11)
        def majorVersion = currentJdkVersion.split('\\.')[0] as Integer

        if (majorVersion != expectedVersion) {
            throw new GradleException(
                "‚ùå JDK version mismatch!\n" +
                "Expected: JDK ${expectedVersion}\n" +
                "Current:  JDK ${majorVersion} (${currentJdkVersion})\n"
            )
        } else {
            logger.lifecycle("‚úÖ JDK version validated: ${currentJdkVersion}")
        }
    }
}